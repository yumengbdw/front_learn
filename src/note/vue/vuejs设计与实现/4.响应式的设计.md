本章首先要明确的是最基本的例子要在心中

副作用函数首先取值obj.name 然后给dom设置值。
effect(){
    document.body.innerText = obj.name
}


所以取值的时候收集依赖。 一旦其他逻辑改变了name的事。将收集到的依赖方法运行即effect方法即可动态更新页面上的显示。

最终
>当 操作发生时，将副作用函数收集到“桶”中;
>当 操作发生时，从“桶”中取出副作用函数并执行。

遇到问题
1. obj中的其他数据更改也会执行副作用函数。
> 引入key机制从 `{target1: { function} }`变为 `{target1: { key: {function}} }`
最外层weakMap{map{set{}}}
这样当key值变化的时候，即set方法调用的时候，更新effect函数数组 effectList = effectFuncList.get(target).get(key)
遍历effectList执行里面保存的副作用函数，

2. obj.show ? obj.name : '默认数据'   这种 当show为false 的时候，name变化无需更新，结果仍旧更新。
分析问题，就是依赖关系没变化。
show 为true  ---> get手机依赖 ---> 得到   target1：name：func和 target1：show：func
但是show为false ----> 调用set方法，的时候清空所有依赖，给effectFunc赋值。 ---> 调用get函数重新收集依赖。



3.  嵌套effect和effect栈 


```js

let activeEffect
function effect(fn) {
    const effectFn = () => {
        cleanup(effectFn)
        activeEffect = effectFn
        fn()
    }
    effectFn.deps = []
    effectFn()
}



// effectFn1 嵌套了 effectFn2 
effect(function effectFn1() {
    console.log('effectFn1 执行')
    effect(function effectFn2() { 
        console.log('effectFn2 执行' )
        temp2 = obj.bar 
    })
    // 在 effectFn1 中读取 obj.foo 属性 
    temp1 = obj.foo
 })

```

依赖收集阶段
    1. 外面effect执行--->effectFn1 执行 ----> activeEffect = effect1    打印console.log('effectFn1 执行')
    2. 里面effect执行--->effectFn2 执行 ----> activeEffect = effect2     打印 console.log('effectFn2 执行' )
    3. 执行effectFn2 里面的取值操作`obj.bar`会存储依赖 {target:{bar: effect2}}
    4. 执行`obj.foo`取值操作 收集依赖  会存储依赖 {target:{foo: effect2}}

    修改`obj.foo = 122 `的时候 调用set函数，执行
    5. {target:{foo: effect2}} 执行effect2   打印 console.log('effectFn2 执行' )


很明显错误。我们希望是{target:{foo: effect1}}  {target:{bar: effect2}}


修改此问题，在收集依赖的时候用数组。


```js

let activeEffect
const effectStack = []
function effect(fn) {
    const effectFn = () => {
        cleanup(effectFn)
        activeEffect = effectFn
        effectStack.push(effectFn)
        fn() //调用方法的时候如果有嵌套会重新走上面代码，相当于effectStack收集完了所有嵌套的方法。当执行一次的时候pop一次。这样可以保证收集到的依赖是一一对应的。
        effectStack.pop()
        activeEffect = effectStack[effectStack.length - 1]
    }
    effectFn.deps = []
    effectFn()
}

```

4. 无限循环递归
effect(() => obj.foo++)

=== obj.foo = obj.foo + 1

即同一个方法先读(收集依赖函数)后设置值(调用依赖函数)从而无限循环了。
很容易，这种情况其实不需要执行依赖函数。
即set函数的时候，判断当前的activeEffect副作用函数和要执行的是不是同一个，是同一个则不执行。

5. 调度执行
当调用set函数使trigger触发副作用函数中心执行的时候，有能力决定副作用函数执行时机，次数，以及方式叫做调度执行

所谓调度其实就是执行副作用函数的时候，调用穿进去的调度函数，把执行权交给用户自己决定。
```js
function effect(fn, options = {}) {
    const effectFn = () => {
        cleanup(effectFn)
        // 当调用 effect 注册副作用函数时，将副作用函数赋值给 activeEffect
        activeEffect = effectFn
        // 在调用副作用函数之前将当前副作用函数压栈
        effectStack.push(effectFn)
        fn()
        // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把activeEffect 还原为之前的值
        effectStack.pop()
        activeEffect = effectStack[effectStack.length - 1]
    }
    // 将 options 挂载到 effectFn 上
    effectFn.options = options // 新增
    // activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合
    effectFn.deps = []
     effectFn()
}
```

6. 计算属性computed和lazy


effect(fn, {lazy: true})




options.lazy 为 true 时，则不立即执行副作用函数

```s
function effect(fn, options = {}) {
    //......省略代码......
    effectFn.deps = []
    if (!options.lazy) { // 新增
         effectFn()
    }

     return effectFn // 新增
}
```


我们将传递给effect的函数fn当成getter的时候，这个getter可以返回任何值

```js
const effectFn = effect(() => {
   return obj.foo + obj.bar
}, {lazy: true})

// value obj.foo + obj.bar的值 
const value = effectFn()

```

> 但是执行effectFn实际上是执行了fn并不会有返回值。 所以需要将fn函数结果返回

改造effect函数

```js
function effect(fn, options = {}) {

    const effectFn = () => {
        cleanup(effectFn)
        // 当调用 effect 注册副作用函数时，将副作用函数赋值给 activeEffect
        activeEffect = effectFn
        // 在调用副作用函数之前将当前副作用函数压栈
        effectStack.push(effectFn)
        const res = fn() // 新增
        // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把activeEffect 还原为之前的值
        effectStack.pop()
        activeEffect = effectStack[effectStack.length - 1]

        return res
    }

     // 将 options 挂载到 effectFn 上
    effectFn.options = options // 新增
    // activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合
    effectFn.deps = []
    if (!options.lazy) { // 新增
         effectFn()
    }
     return effectFn // 新增

}

```
所以我们就可以实现computed函数

```js
// 传进getter函数
function computed(getter) {
    const effectFn = effect(getter, {lazy: true})

    const obj = {
        // 当读取value的时候实际上是执行的effectFn()
        get value {
            return effectFn()
        }
    }
    return obj
}


// 传getter函数进去。
const sumRes = computed(() => obj.foo + obj.bar)
当读取sumRes.value的时候会执行副作用函数，即obj.foo + obj.bar的值
```



1. 执行computed函数
2. 会执行effct函数返回值赋值给effectFn  当前的副作用函数就是传进去的getter函数。
3. 然后执行obj.foo 将foo和bar对应的副作用函数均为getter。  
4. 当改变obj.foo的值的时候，会调用getter函数。




# 非原始值的响应式系统
proxy只能代理对象，拦截并重新定义。
代理： 即对一个对象的基本语义操作(对象的读取等，函数的执行操作)的代理

### 基本语义操作
```js
/**
 * @param1 obj 代理的对象
 * @param2 {get, set} 被代理的方法集合
 */
cons p = new Proxy(obj, {
    get(){},
    set(){}
})
```



函数也是对象，所以也可以拦截函数的执行
```js
const p2 = new Proxy(fn, {
    apply(target, thisArg, argArray) {
        target.call(thisArg, argArray)
    }
})

p2('hcy')
```


# 非基本操作： 复合操作---> 对象中函数的调用


对象中函数调用的基本语义操作：  1.obj.get操作得到obj.fn属性， 2.语义的调用， 即调用fn方法obj.fn()



reflect

任何在proxy中能够找到的方法都能在reflect中找到同名函数。
obj.foo   === Reflect.get(obj, 'foo')


由于存在下面这种情况，当调用 p.bar的时候this指向其实已经变了，相当于调用了obj.foo  obj并不是我们的代理对象，所以不会foo变化不会响应

cons p = new Proxy(obj, {
    get(target, key)){
        return target[key]
    },
    set(){}
})

const obj = {
    foo: 1, 
    get bar() {
        return this.foo
    }
}